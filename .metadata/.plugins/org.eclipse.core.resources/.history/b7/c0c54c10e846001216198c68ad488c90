
public abstract class Voiture {
	protected int type;
	protected int cVitesse;
	protected Moteur moteur;
	protected int habilite;
	protected int freinage;
	
	protected Circuit circuit;
	protected int iSegment; 
	protected Position cPosition;
	protected int vitesseMaxSegment;
	
	public static int TYPE_VOITURE_ESSENCE = 1;
	public static int TYPE_VOITURE_ELECTRIQUE = 2;
	public static int TYPE_VOITURE_HYBRIDE = 3;
		
	public abstract boolean hasToFill();
	
	public int getType() {
		return this.type;
		
		//Pour mettre ˆ jour cPosition.getSegment().getVitesseMaxEffective(habilite);
	}
	
	public void setId(int pType) {
		this.type = pType;
	}
	
	public int getCVitesse() {
		return this.cVitesse;
	}
	
	public void setCVitesse(int pCVitesse) {
		this.cVitesse = pCVitesse;
	}
	
	public void updateVitesse() {
		//on regarde si on doit freiner
		boolean freinage = true;
		if(isFreinage()) {
			this.cVitesse -= 
		}
		else {
			//on applique la vitesse potentielle maximum juste gr‰ce au moteur
			this.cVitesse = this.moteur.getVitessePotentielle(this.cVitesse);
			if(this.cVitesse >= this.vitesseMaxSegment) {
				this.cVitesse = this.vitesseMaxSegment;
			}
			
		}
		
	}
	
	public boolean isFreinage() {
		boolean res = false;	
		Segment nextSegment = this.circuit.getSegmentAt(iSegment);
		
		int distanceAvantSegment = Position.AVANCEMENT_MAX - this.cPosition.getAvancement();
		int distanceNecessaire = calculeDistanceFreinage(this.cVitesse) - calculeDistanceFreinage(nextSegment.getVitesseMaxEffective(habilite));
		
		if(distanceNecessaire <= distanceAvantSegment) {
			res = true;
		}
		
		
		return res;
	}
	
	public int calculeDistanceFreinage(int vitesse) {
		return vitesse * (10 / freinage);
	}
	
}
